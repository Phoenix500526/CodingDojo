## 计分规则：

一局比赛共有 10 个计分格。选手在每一格里有 2 次机会击倒所有 10 个球瓶，共有以下三种情况：

* 如果球手在一个计分格里，第一投便击倒全部 10 个球瓶，则记为一次“strike”， 无需进行第二投。
* 如果球手在一个计分格里，两次投球才将全部 10 个球瓶击倒， 则记为一次“spare”。例如，球手可能第一投击倒 7 个球瓶，第二投击倒余下 3 个。 如果球手第一投没有击倒任何球瓶，但第二投击倒所有 10 支球瓶，鉴于球手两次投球才击倒所有球瓶，仍记为一次 “spare” 而非 “strike”。
* 如果球手两次投球后仍未能击倒所有 10 支球瓶，则记为一次 “miss”。

对应的计分方法如下：

* 若球手打出 “strike" ，则在当格第一行记一个“X”。全中分数为“10 分加上球手之后两次投球击倒瓶数”。例如，如果球手在第一格打出全中，而后在第二格第一球击倒 5 瓶，第二球击倒 4 瓶，则第一格最终分数为 19。如果球手接连打出两个全中，则之后一投的分数仍然记入第一格内。例如，如果球手在前三格均打出全中，则第一格最终分数为 30。
* 若球手打出 “spare" ，那么计分卡第一格记录球员第一投击倒的球瓶数，第二格画一条反斜线。补中分数为“10 分加上球手下一格第一投击倒的瓶数”。
   例如：如果球员在第一格补中，第二格第一投击倒 7 支球瓶，则第一格最终分数为 17。
* 若球手打出 ”miss“，只需将两次投球分别击倒的瓶数相加，即可得出本格最终分数。例如：如果球手第一轮第一投击倒 3 支球瓶，第二投击倒 2 支球瓶，则第一格计 5 分。如果球手第二轮共击倒 7 支球瓶，则第二格计 12（5+7） 分。

第 10 格如果打出 “strike” ，则追加两次投球机会；如果打出“spare”，则追加一次投球机会。



## 构造用例 （X:strike，/:spare，-:miss）

题目中所给出的 10 格积分格，其可能非常之大，难以分析。考虑缩小问题域，以 2 格计分格为一般情况，1 格计分格为特例边界情况，采用如下用例：

#### X + X + X + X

|                   | frame1 | frame2 | bonus_1 | bonus_2 |
| ----------------- | ------ | ------ | ------- | ------- |
| 奖励分数2         | 10     | 10     |         |         |
| 奖励分数1         | 10     | 10     |         |         |
| 净得分            | 10     | 10     | 10      | 10      |
| 当前 frame 的状况 | X      | X      | X       | X       |
| bonus             | 0      | 0      | 0       | 0       |

最终得分： 60 分

#### X + X + X + (/ 或 -)

|                   | frame1 | frame2 | bonus_1 | bonus_2 |
| ----------------- | ------ | ------ | ------- | ------- |
| 奖励分数2         | 10     | 2      |         |         |
| 奖励分数1         | 10     | 10     |         |         |
| 净得分            | 10     | 10     |         |         |
| 当前 frame 的状况 | X      | X      | X       | {2, y}  |
| bonus             | 0      | 0      | 0       | 0       |

最终得分：52 分

#### X + X + (/ 或 -)

|                   | frame1 | frame2 | bonus_1 | bonus_2 |
| ----------------- | ------ | ------ | ------- | ------- |
| 奖励分数2         | 2      | y      |         |         |
| 奖励分数1         | 10     | 2      |         |         |
| 净得分            | 10     | 10     |         |         |
| 当前 frame 的状况 | X      | X      | {2, y}  |         |
| bonus             | 0      | 0      |         |         |

最终得分：34 + y 分

#### X + / + X

|                   | frame1 | frame2 | bonus_1 | bonus_2 |
| ----------------- | ------ | ------ | ------- | ------- |
| 奖励分数2         | 8      |        |         |         |
| 奖励分数1         | 2      | 10     |         |         |
| 净得分            | 10     | 10     |         |         |
| 当前 frame 的状况 | X      | {2, 8} | X       |         |
| bonus             | 0      | 0      |         |         |

最终得分：40 分

#### (X 或 /) + -

|                   | frame1 | frame2 | bonus_1 | bonus_2 |
| ----------------- | ------ | ------ | ------- | ------- |
| 奖励分数2         | (1)    |        |         |         |
| 奖励分数1         | 1      |        |         |         |
| 净得分            | 10     | 2      |         |         |
| 当前 frame 的状况 | X 或 / | {1, 1} |         |         |
| bonus             | 0      | 0      |         |         |

最终得分：13 或 14 分



## 状态设计

从前面的用例除法，将一场保龄球比赛分为两个阶段：普通得分、加时结算，其中这两个阶段的分界线是当前的 frame_ID \> max_frame，前者要考虑保留最多前两次 bonus，而后者不需要

比赛相关状态：game_start 和 game_over

```C++
struct game_strt{};
struct game_over{};
```

普通得分阶段 normal_stage：strike、sparse、miss, 对应的状态转换函数为 normal_stage

```C++
struct strike{};
struct spare{};
struct miss{
    int first_score;
    int second_score;
};
vector<detail::bonus_t> bonus_rec(frame + 2, detail::bonus_t::zero);

// 支持自减，且 zero 自减始终为 0
enum class bonus_t { zero, one, two, };
```

加时结算阶段：clear_stage, 对应的状态转换函数为 clear_stage, 从 clear 到 game_over 的转换依据是 m_bonus[m_maxFrame] == bonus_t::zero 

```C++
struct clear{};
```

